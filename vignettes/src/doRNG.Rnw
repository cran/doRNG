% 
\documentclass[a4paper,12pt]{article}
\usepackage{Sweave}

%\VignetteIndexEntry{Using the package doRNG}
%\VignetteDepends{doRNG,bibtex,doParallel,knitr,doRedis,rbenchmark}

\ifdefined\knitrout
  \renewenvironment{knitrout}{\begin{footnotesize}}{\end{footnotesize}}
\else
\fi

\usepackage{a4wide}
\usepackage{xspace}
\usepackage[colorlinks]{hyperref} % for hyperlinks
\usepackage[minnames=1,maxnames=2]{biblatex}
<<bib, echo=FALSE, results='asis', warning=FALSE>>=
cat("\\bibliography{", file.path(system.file(package='doRNG'), "REFERENCES"),
 "}\n", sep='') 
@
\bibliography{Rpackages}
\newcommand{\citet}[1]{\citeauthor{#1}~\cite{#1}}

\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[toc]{multitoc}

% R stuff
\let\proglang=\textit
\let\code=\texttt 
\newcommand{\Rcode}{\texttt}
\newcommand{\pkgname}[1]{\textit{#1}}
\newcommand{\Rpkg}[1]{\pkgname{#1} package\xspace}

\newcommand{\graphwidth}{0.9\columnwidth}
%\newcommand{\revision}[2][]{\textcolor{blue}{#2}{\bf \textcolor{blue}{$\blacksquare$ REV[#1]}}}
% CRAN
\newcommand{\CRANurl}[1]{\url{http://cran.r-project.org/package=#1}}
\newcommand{\pkgnameU}[1]{\href{http://cran.r-project.org/package=#1}{\pkgname{#1}}\footnote{\CRANurl{#1}}}
\newcommand{\CRANpkg}[1]{\href{http://cran.r-project.org/package=#1}{\pkgname{#1}} package\footnote{\CRANurl{#1}}}
\newcommand{\citeCRANpkg}[1]{\CRANpkg{#1}~\cite{#1}}
% Bioconductor
\newcommand{\BioCurl}[1]{\url{http://www.bioconductor.org/packages/release/bioc/html/#1.html}}
\newcommand{\BioCpkg}[1]{\href{http://www.bioconductor.org/packages/release/bioc/html/#1.html}{\pkgname{#1}} package\footnote{\BioCurl{#1}}}
\newcommand{\citeBioCpkg}[1]{\BioCpkg{#1}~\cite{#1}}
% Bioconductor annotation
\newcommand{\BioCAnnurl}[1]{\url{http://www.bioconductor.org/packages/release/data/annotation/html/#1.html}}
\newcommand{\BioCAnnpkg}[1]{\href{http://www.bioconductor.org/packages/release/data/annotation/html/#1.html}{\Rcode{#1}} annotation package\footnote{\BioCAnnurl{#1}}}
\newcommand{\citeBioCAnnpkg}[1]{\BioCAnnpkg{#1}~\cite{#1}}

% clever references
%\usepackage[noabbrev, capitalise, nameinlink]{cleveref}

\title{Using the \code{doRNG} package\\
{\small \Rpkg{doRNG} -- Version \Sexpr{packageVersion('doRNG')}}}
\author{Renaud Gaujoux}

\begin{document}

\maketitle

\tableofcontents

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Research reproducibility is an issue of concern, e.g. in bioinformatics
\cite{Hothorn2011,Stodden2011,Ioannidis2008}.
Some analyses require multiple independent runs to be performed, or are amenable to a split-and-reduce scheme.
For example, some optimisation algorithms are run multiple times from different
random starting points, and the result that achieves the least approximation error is selected.
The \citeCRANpkg{foreach} provides a very convenient way to perform parallel computations, with different parallel environments such as MPI or Redis, using a transparent loop-like syntax:

<<init, echo=FALSE, message=FALSE>>=
options(width=90)
@

<<foreach>>=
# load and register parallel backend for multicore computations
library(doParallel)
cl <- makeCluster(2)
registerDoParallel(cl)

# perform 5 tasks in parallel
x <- foreach(i=1:5) %dopar% { 
	i + runif(1) 
}
unlist(x)
@

For each parallel environment a \emph{backend} is implemented as a specialised \code{\%dopar\%} operator, which performs the setup and pre/post-processing specifically required by the environment (e.g. export of variable to each worker).
The \code{foreach} function and the \code{\%dopar\%} operator handle the generic
parameter dispatch when the task are split between worker processes, as well
as the reduce step -- when the results are returned to the master worker.

When stochastic computations are involved, special random number generators must
be used to ensure that the separate computations are indeed statistically independent -- unless otherwise wanted -- and that the loop is reproducible.
In particular, standard \code{\%dopar\%} loops are not reproducible:
<<dopar, tidy=FALSE>>=
# with standard %dopar%: foreach loops are not reproducible
set.seed(123)
res <- foreach(i=1:5) %dopar% { runif(3) }
set.seed(123)
res2 <- foreach(i=1:5) %dopar% { runif(3) }
identical(res, res2)
@

A random number generator commonly used to achieve reproducibility is the
combined multiple-recursive generator from \citet{Lecuyer1999}.
This generator can generate independent random streams, from a 6-length numeric seed.
The idea is then to generate a sequence of random stream of the same length
as the number of iteration (i.e. tasks) and use a different stream when computing each
one of them.

The \citeCRANpkg{doRNG} provides convenient ways to implement reproducible
parallel \code{foreach} loops, independently of the parallel backend used to perform the computation.
We illustrate its use, showing how non-reproducible loops can be made
reproducible, even when tasks are not scheduled in the same way in two separate
set of runs, e.g.
when the workers do not get to compute the same number of tasks or the number of workers is different.
The package has been tested with the \pkgnameU{doParallel} and \pkgnameU{doMPI}
packages \cite{doMPI,doParallel}, but should work with other backends such as
provided by the \citeCRANpkg{doRedis}. 

\section{The \texttt{\%dorng\%} operator}

The \Rpkg{doRNG} defines a new generic operator, \code{\%dorng\%}, to be used
with foreach loops, instead of the standard {\%dopar\%}.
Loops that use this operator are \emph{de facto} reproducible.

<<dorng, tidy=FALSE>>=

# load the doRNG package
library(doRNG)

# using %dorng%: loops _are_ reproducible
set.seed(123)
res <- foreach(i=1:5) %dorng% { runif(3) }
set.seed(123)
res2 <- foreach(i=1:5) %dorng% { runif(3) }
identical(res, res2)
@

\subsection{How it works}
For a loop with $N$ iterations, the \code{\%dorng\%} operator internally
performs the following tasks:
\begin{enumerate}
  \item generate a sequence of random seeds $(S_i)_{1\leq i\leq N}$ for the \proglang{R} random number
  generator \code{"L'Ecuyer-CMRG"} \cite{Lecuyer1999}, using
  the function \code{nextRNGStream} from the \citeCRANpkg{parallel},
  which ensure the different RNG streams are statistically independent;
  \item modify the loop's \proglang{R} expression so that the random number
  generator is set to \code{"L'Ecuyer-CMRG"} at the beginning of each
  iteration, and is seeded with consecutive seeds in $(S_n)$: iteration $i$ is
  seeded with $S_i$, $1\leq i\leq N$;
  \item call the standard \code{\%dopar\%} operator, which in turn
  calls the relevant (i.e. registered) foreach parallel backend;
  \item store the whole sequence of random seeds as an attribute in the result
  object:
<<attr>>=
attr(res, 'rng')
@
\end{enumerate}

\subsection{Seeding computations}

Sequences of random streams for \code{"L'Ecuyer-CMRG"} are generated
using a 6-length integer seed:
<<nextRNGstream>>=
nextRNGstream(1:6)
@

However, the \code{\%dorng\%} operator provides alternative -- convenient --
ways of seeding reproducible loops.

\begin{description}
  \item[\code{set.seed}:] as shown above, calling \code{set.seed} before the
  loop ensure reproducibility of the results, using a single integer as a seed. The actual 6-length seed is
then classically within the call to \code{RNGkind("L'Ecuyer-CMRG")}.
  \item[\code{.options.RNG} with single integer:] the \code{\%dorng\%} operator
  implements an option that can be passed in the \code{foreach} statement, with
  the same arguments accepted by \code{set.seed}:
<<options_single>>=
# use a single numeric as a seed
s <- foreach(i=1:5, .options.RNG=123) %dorng% { runif(3) }
identical(s, res)

## Pass the Normal RNG kind to use within the loop
# results are identical if not using the Normal kind in the loop
optsN <- list(123, normal.kind="Ahrens")
resN.U <- foreach(i=1:5, .options.RNG=optsN) %dorng% { runif(3) }
identical(resN.U[1:5], res[1:5])

# Results are different if the Normal kind is used and is not the same
resN <- foreach(i=1:5, .options.RNG=123) %dorng% { rnorm(3) }
resN1 <- foreach(i=1:5, .options.RNG=optsN) %dorng% { rnorm(3) }
resN2 <- foreach(i=1:5, .options.RNG=optsN) %dorng% { rnorm(3) } 
identical(resN[1:5], resN1[1:5])
identical(resN1[1:5], resN2[1:5])
@
\item[\code{.options.RNG} with 6-length:] the actual 6-length integer seed used
for the first RNG stream may be passed via \code{options.RNG}: 
<<options_6length>>=
# use a 6-length numeric
s <- foreach(i=1:5, .options.RNG=1:6) %dorng% { runif(3) }
attr(s, 'rng')[1:3]
@
\item[\code{.options.RNG} with 7-length:] a 7-length integer seed may also be
passed via \code{options.RNG}, which is useful to seed a loop with the value of
\code{.Random.seed} as used in some iteration of another loop\footnote{Note that
the RNG kind is then always required to be the \code{"L'Ecuyer-CMRG"}, i.e.
the first element of the seed must have unit 7 (e.g. 407 or 107).}:
<<options_7length>>=
# use a 7-length numeric, used as first value for .Random.seed
seed <- attr(res, 'rng')[[2]]
s <- foreach(i=1:5, .options.RNG=seed) %dorng% { runif(3) }
identical(s[1:4], res[2:5])
@
\item[\code{.options.RNG} with complete sequence of seeds:] the complete
description of the sequence of seeds to be used may be
passed via \code{options.RNG}, as a list or a matrix with the seeds in columns.
This is useful to seed a loop exactly as desired, e.g. using an RNG
other than \code{"L'Ecuyer-CMRG"}, or using different RNG kinds in each iteration, which probably have different seed
length, in order to compare their stochastic properties.
It also allows to reproduce \code{\%dorng\%} loops without knowing their seeding
details:

<<options_list>>=
# reproduce previous %dorng% loop
s <- foreach(i=1:5, .options.RNG=res) %dorng% { runif(3) }
identical(s, res)

## use completely custom sequence of seeds (e.g. using RNG "Marsaglia-Multicarry")
# as a matrix
seedM <- rbind(rep(401, 5), mapply(rep, 1:5, 2))
seedM
sM <- foreach(i=1:5, .options.RNG=seedM) %dorng% { runif(3) }
# same seeds passed as a list
seedL <- lapply(seq(ncol(seedM)), function(i) seedM[,i])
sL <- foreach(i=1:5, .options.RNG=seedL) %dorng% { runif(3) }
identical(sL, sM)
@
\end{description}

\section{Parallel environment independence}
An important feature of \code{\%dorng\%} loops is that their result is
independent of the underlying parallel physical settings.
Two separate runs seeded with the same value will always produce the same
results.
Whether they use the same number of worker processes, parallel backend or
task scheduling does not influence the final result.
This also applies to computations performed sequentially with the \code{doSEQ}
backend.
The following code illustrates this feature using 2 or 3 workers.

<<schedule, tidy=FALSE>>=

# define a stochastic task to perform
task <- function() c(pid=Sys.getpid(), val=runif(1))

# using the previously registered cluster with 2 workers
set.seed(123)
res_2workers <- foreach(i=1:5, .combine=rbind) %dorng% {
	task()
}
# stop cluster
stopCluster(cl)

# Sequential computation
registerDoSEQ()
set.seed(123)
res_seq <- foreach(i=1:5, .combine=rbind) %dorng% {
	task() 
}
#

# Using 3 workers
cl <- makeCluster(3)
registerDoParallel(cl)
set.seed(123)
res_3workers <- foreach(i=1:5, .combine=rbind) %dorng% { 
	task()
}

# task schedule is different
pid <- rbind(res1=res_seq[,1], res_2workers[,1], res2=res_3workers[,1])
storage.mode(pid) <- 'integer'
pid
# results are identical
identical(res_seq[,2], res_2workers[,2]) && identical(res_2workers[,2], res_3workers[,2])
@

\section{Reproducible \texttt{\%dopar\%} loops}

The \Rpkg{doRNG} also provides a non-invasive way to convert \code{\%dopar\%}
loops into reproducible loops, i.e. without changing their actual definition.
It is useful to quickly ensure the reproducibility of existing code or functions
whose definition is not accessible (e.g. from other packages).
This is achieved by registering the \code{doRNG} backend:

<<registerDoRNG>>=
registerDoRNG(123)
res_dopar <- foreach(i=1:5) %dopar% { runif(3) }
identical(res_dopar, res)
attr(res_dopar, 'rng')
@

\section{Reproducibile sets of loops}

Sequences of multiple loops are reproducible, whether using the
\code{\%dorng\%} operator or the registered \code{doRNG} backend:

<<multiple, tidy=FALSE>>=
set.seed(456)
s1 <- foreach(i=1:5) %dorng% { runif(3) }
s2 <- foreach(i=1:5) %dorng% { runif(3) }
# the two loops do not use the same streams: different results
identical(s1, s2)

# but the sequence of loops is reproducible as a whole
set.seed(456)
r1 <- foreach(i=1:5) %dorng% { runif(3) }
r2 <- foreach(i=1:5) %dorng% { runif(3) }
identical(r1, s1) && identical(r2, s2) 

# one can equivalently register the doRNG backend and use %dopar%
registerDoRNG(456)
r1 <- foreach(i=1:5) %dopar% { runif(3) }
r2 <- foreach(i=1:5) %dopar% { runif(3) }
identical(r1, s1) && identical(r2, s2)
@

\section{Performance overhead}

The extra setup performed by the \code{\%dorng\%} operator leads to a slight
performance over-head, which might be significant for very quick computations, but should
not be a problem for realistic computations.
The benchmarks below show that a \code{\%dorng\%} loop may take up to two
seconds more than the equivalent \code{\%dopar\%} loop, which is not significant
in practice, where parallelised computations typically take several minutes.  

<<perf, cache=TRUE>>=
# load rbenchmark
library(rbenchmark)

# comparison is done on sequential computations
registerDoSEQ()
rPar <- function(n, s=0){ foreach(i=1:n) %dopar% { Sys.sleep(s) } }
rRNG <- function(n, s=0){ foreach(i=1:n) %dorng% { Sys.sleep(s) } }

# run benchmark
cmp <- benchmark(rPar(10), rRNG(10)
			, rPar(50), rRNG(50)
			, rPar(100), rRNG(100)
			, rPar(10, .1), rRNG(10, .1)
			, rPar(100, .01), rRNG(100, .01)
			, replications=50)
# order by increasing elapsed time
cmp[order(cmp$elapsed), ]
@


\section*{Cleanup}
<<stopCluster>>=
stopCluster(cl)
@

\section*{Session information}
\addcontentsline{toc}{section}{Session information}
<<session_info, echo=FALSE, comment=NA>>=
sessionInfo()
@

\printbibliography[heading=bibintoc]
%\bibliographystyle{plain}
%<<bib, echo=FALSE, results='asis', warning=FALSE>>=
%cat("\\bibliography{Rpackages,", file.path(system.file(package='doRNG'), "REFERENCES"),
% "}\n", sep='') 
%@

<<bibtex_entries, echo=FALSE, include=FALSE>>=
library(bibtex)
write.bib(c('foreach', 'doRNG', 'parallel', 'doMPI', 'doParallel', 'doRedis'), file='../Rpackages.bib')
@

\end{document}
